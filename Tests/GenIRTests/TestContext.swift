import Foundation
@testable import gen_ir

class TestContext {
	enum Error: Swift.Error {
		case commandFailed(Process.ReturnValue)
	}

	static let baseTestingPath: URL = {
		// HACK: use the #file magic to get a path to the test case... Maybe there's a better way to do this?
		URL(fileURLWithPath: #file.replacingOccurrences(of: "Tests/GenIRTests/TestContext.swift", with: ""))
	}()

	static let testAssetPath: URL = {
		baseTestingPath.appendingPathComponent("TestAssets")
	}()

	func clean(test path: URL) throws -> Process.ReturnValue {
		return try Process.runShell(
			"/usr/bin/xcodebuild",
			arguments: [
				"clean"
			],
			runInDirectory: path.deletingLastPathComponent(),
			joinPipes: true
		)
	}

	func build(
		test path: URL,
		scheme: String,
		additionalArguments: [String] = []
	) throws -> Process.ReturnValue {
		if shouldDeployPodsBuildSystemHack {
			if let returnValue = try deployPodsBuildSystemHack(path) {
				guard returnValue.code == 0 else {
					throw Error.commandFailed(returnValue)
				}
			}
		}

		let clean = try clean(test: path)

		guard clean.code == 0 else {
			throw Error.commandFailed(clean)
		}

		let process = try Process.runShell(
			"/usr/bin/xcodebuild",
			arguments: [
				"archive",
				path.pathExtension == "xcworkspace" ? "-workspace" : "-project",
				path.filePath,
				"-scheme", scheme,
				"-destination", "generic/platform=iOS",
				"-configuration", "Debug",
				"-archivePath", archive.filePath,
				"DEBUG_INFORMATION_FORMAT=dwarf-with-dsym",
				"ENABLE_BITCODE=NO"
			]
			+ additionalArguments,
			runInDirectory: temporaryDirectory,
			joinPipes: true
		)

		if process.code != 0 {
			print("""
			code: \(process.code)
			stdout: \(process.stdout ?? "nil")
			stderr: \(process.stderr ?? "nil")
			""")
			throw Error.commandFailed(process)
		} else if let stdout = process.stdout {
			try stdout.write(to: buildLog, atomically: true, encoding: .utf8)
		}

		return process
	}

	let archive: URL
	let buildLog: URL
	let temporaryDirectory: URL
	let shouldDeployPodsBuildSystemHack: Bool

	init(podsBuildSystemHack: Bool = false) throws {
		temporaryDirectory = try FileManager.default.temporaryDirectory(named: "gen-ir-tests-\(UUID().uuidString)")
		archive = temporaryDirectory.appendingPathComponent("x.xcarchive")
		buildLog = temporaryDirectory.appendingPathComponent("build.log")
		shouldDeployPodsBuildSystemHack = podsBuildSystemHack
	}
}

extension TestContext {
	// TODO: we should look into how this will effect users and whether we should do this on their behalf.... (probably yes)
	/// Pods has a weird default for legacy build systems where they set SYMROOT to ${SRCROOT}../build
	/// Then, Apple has this stupid bug where they don't mark this folder as being generated by the build system
	/// This dates back until at _least_ iOS 12 - with no fix. Because Apple is Apple and they hate developers
	/// This function will mark the build folder as created by the build system so `xcodebuild clean` works.
	private func deployPodsBuildSystemHack(_ path: URL) throws -> Process.ReturnValue? {
		let buildPath = path.deletingLastPathComponent().appendingPath(component: "build")

		if !FileManager.default.directoryExists(at: buildPath.appendingPath(component: "Pods.build")) {
			return nil
		}

		return try Process.runShell(
			"/usr/bin/xattr",
			arguments: [
				"-w",
				"com.apple.xcode.CreatedByBuildSystem",
				"true",
				buildPath.filePath
			]
		)
	}
}
